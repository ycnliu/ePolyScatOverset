#!/usr/bin/python

# Make 3d plots of amplitudes generated by CnvLinFull for a small selection of
# field orientations
#
# A different pdf is generated for each view for all of the field directions found
# in the file specified in the argument list of the call to the script, i.e. in sys.argv[1]

import sys
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class DataPoint():
    def __init__(self, Entry):
       self.ip = Entry[0]
       self.irdimTarg = Entry[1]
       self.Eng = Entry[2]
       self.ThEleD = Entry[3]
       self.PhiEleD = Entry[4]
       self.ThFieldD = Entry[5]
       self.PhiFieldD = Entry[6]
       self.Amp = complex(Entry[7],Entry[8])

tol=1.0e-4
def CompReal(x,y) :
	if abs(x-y) < tol :
		return 0
	elif x > y :
		return 1
	else :
		return -1

def RealIn(x,y):
	""" return logical true if x is in y list """
	for iy in y :
		if CompReal(x,iy) == 0 :
			return True
	return False

def RealIndex(x,y) :
	""" return the index of x in y """
	for iy in range(len(y)) :
		if CompReal(x,y[iy]) == 0 :
			return iy
	return -1

def CompReal2(x,y) :
	""" comparison of tuple of two real numbers  """
	CompFirst=CompReal(x[0],y[0])
	if CompFirst != 0 :
		return CompFirst
	else :
		return CompReal(x[1],y[1])

def Real2In(x,y):
	""" return logical true if x is in y list of tuples of two real numbers """
	for iy in y :
		if CompReal2(x,iy) == 0 :
			return True
	return False

def Real2Index(x,y) :
	""" return the index of x in y in list of tuples of two real numbers """
	for iy in range(len(y)) :
		if CompReal2(x,y[iy]) == 0 :
			return iy
	return -1
	
FileName=sys.argv[1]
print "Read File",FileName


DataIn=[]
infile=open(FileName,"r")

inline=next(infile)
NPhiEle, NThEle, NThField, NPhiField, nrdimTarg, nip = map(int,inline.split())
print "NPhiEle", NPhiEle
print "NThEle", NThEle
print "NPhiField", NPhiField
print "NThField", NThField
print "nrdimTarg",nrdimTarg
print "nip", nip

for line in infile :
	if len(line.strip()) != 0 :
		linesplit = line.split()
		DataIn.append(DataPoint(map(int,linesplit[0:2])+map(float,linesplit[2:])))
infile.close()

UniqTheta=[]
UniqPhi=[]
UniqField=[]  # unique field directions

for ele in DataIn :
	if not RealIn(ele.ThEleD,UniqTheta) :
		UniqTheta.append(ele.ThEleD)
	if not RealIn(ele.PhiEleD,UniqPhi) :
		UniqPhi.append(ele.PhiEleD)
	if not Real2In((ele.ThFieldD,ele.PhiFieldD),UniqField) :
		UniqField.append((ele.ThFieldD,ele.PhiFieldD))

UniqTheta.sort(cmp=CompReal)
UniqPhi.sort(cmp=CompReal)
UniqField.sort(cmp=CompReal2)

print "UniqTheta", len(UniqTheta)
print "UniqPhi", len(UniqPhi)
print "UniqField",UniqField

shape2D=(len(UniqPhi)),(len(UniqTheta))

fsz=10
subfig=[]
numplts=len(UniqField)
pltlayout=int(np.ceil(np.sqrt(numplts)))

ipuse = 1  # Only do the length form calculation

x=[]
y=[]
z=[]
xmax=0.
xmin=0.
ymax=0.
ymin=0.
zmax=0.
zmin=0.

[theta2D,phi2D]=np.meshgrid(UniqTheta,UniqPhi)
for indx in range(numplts) :
	Data2D=np.zeros(shape2D)
	for ele in DataIn :
		if (ele.ip == ipuse) and (Real2Index((ele.ThFieldD,ele.PhiFieldD),UniqField) == indx) :
			Data2D[RealIndex(ele.PhiEleD,UniqPhi),RealIndex(ele.ThEleD,UniqTheta)] += abs(ele.Amp)**2

# Make phi at 0 and 360 the same by taking the average
	iphi0=RealIndex(0.,UniqPhi)
	iphi360=RealIndex(360.,UniqPhi)
	print "index for 0 and 360 ", iphi0, iphi360
	if iphi0 >= 0 and iphi360>=0 :
		Data2D[iphi0,:] = 0.5*(Data2D[iphi0,:]+Data2D[iphi360,:])
		Data2D[iphi360,:] = Data2D[iphi0,:]

	print "Max Val", np.amax(Data2D)
	
	Data2D =np.maximum(1.0e-6,Data2D)
	
	x.append(np.sin(np.radians(theta2D))*np.cos(np.radians(phi2D))*Data2D)
	y.append(np.sin(np.radians(theta2D))*np.sin(np.radians(phi2D))*Data2D)
	z.append(np.cos(np.radians(theta2D))*Data2D)
	xmax=max(xmax,np.amax(x[-1]))
	xmin=min(xmin,np.amin(x[-1]))
	ymax=max(ymax,np.amax(y[-1]))
	ymin=min(ymin,np.amin(y[-1]))
	zmax=max(zmax,np.amax(z[-1]))
	zmin=min(zmin,np.amin(z[-1]))

# views[] = [elevation, azimuth, label]

views=[[20,-40,"side"],[90,0,"top"],[0,0,"fy"],[0,90,"fx"]]

for thisview in views :
#	fig1=plt.figure(num=Filename, figsize=(5.*pltlayout,5.*pltlayout))
	fig1=plt.figure(figsize=(5.*pltlayout,5.*pltlayout))
	for indx in range(numplts) :
		subfig += [fig1.add_subplot(pltlayout,pltlayout,indx+1,projection='3d')]
		subfig[-1].plot_surface(x[indx],y[indx],z[indx],rstride=1,cstride=1,color='r',linewidth=0.5)
		subfig[-1].elev, subfig[-1].azim = thisview[0], thisview[1]-90  
# Adjustment of azim angle to correspond to matlab definition
# where azim = 0 corresponds to looking along the y axis in the -y to +y direction
		subfig[-1].set_title("Theta N {0:7.1f}   Phi N {1:7.1f}".format(UniqField[indx][0],UniqField[indx][1]) ,fontsize=fsz)
		subfig[-1].set_xlabel('x')
		subfig[-1].set_xlim([1.1*xmin,1.1*xmax])
		subfig[-1].set_ylabel('y')
		subfig[-1].set_ylim([1.1*ymin,1.1*ymax])
		subfig[-1].set_zlabel('z')
		subfig[-1].set_zlim([1.1*zmin,1.1*zmax])

# 
	fig1.suptitle(FileName+" View "+thisview[2])
# plt.show()
# fig1.tight_layout()
	fig1.savefig(FileName+thisview[2]+".pdf")
	
	
